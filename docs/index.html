<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, minimum-scale=1" name="viewport"/>
<meta content="pdoc3 0.11.1" name="generator"/>
<title>analise_utils API documentation</title>
<meta content="" name="description"/>
<link crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" rel="stylesheet"/>
<link crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" rel="stylesheet"/>
<link crossorigin="" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" rel="stylesheet"/>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script crossorigin="" defer="" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
<link href="favicon.ico" rel="icon"/></head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>analise_utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="analise_utils.ArrayOperations"><code class="flex name class">
<span>class <span class="ident">ArrayOperations</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArrayOperations:

    @staticmethod
    def find_max_around_point(matrix : np.ndarray, point : tuple, size : int) -&gt; tuple:
        """Функция выполняет поиск максимального значения в матрице определенного размера вокруг заданной точки.

        Args:
            matrix (np.ndarray):  матрица (двумерный массив) - изображение
            point (tuple): указанная точка - координаты
            size (int): размер области поиска

        Returns:
            tuple: кортеж из трех значений: строкa ```max_row``` и столбец ```max_col``` максимального значения, а также значение ```max_value``` самого большого элемента в указанной области.
        """
        # Get the indices of the smaller region around the point
        row, col = point
        half_size = size // 2
        row_indices = range(max(0, row - half_size), min(matrix.shape[0], row + half_size + 1))
        col_indices = range(max(0, col - half_size), min(matrix.shape[1], col + half_size + 1))

        # Get the smaller region from the original matrix
        smaller_matrix = matrix[np.ix_(row_indices, col_indices)]

        # Find the maximum value in the smaller region
        max_value = np.max(smaller_matrix)

        # Get the coordinates of the maximum value in the original matrix
        max_indices = np.unravel_index(np.argmax(smaller_matrix), smaller_matrix.shape)
        max_row = row_indices[max_indices[0]]
        max_col = col_indices[max_indices[1]]

        return (max_row, max_col, max_value)

    @staticmethod
    def find_center_of_mass(matrix: np.ndarray, point: tuple, size: int) -&gt; tuple:
        """Функция выполняет поиск центра тяжести области методом взвешенного среднего. Функция вычисляет матрицу меньшего размера вокруг указанной точки и находит максимальное значение в этой области. Затем она устанавливает пороговое значение как фракцию максимального значения и находит индексы элементов матрицы, которые превышают этот порог. Если ни один элемент не превышает порог, центр тяжести вычисляется как центр области. В противном случае, используются индексы элементов, превышающих порог, для вычисления центра тяжести методом среднего.

        Args:
            matrix (np.ndarray):  матрица (двумерный массив)
            point (tuple): указанная точка - координаты
            size (int): размер области поиска

        Returns:
            tuple: кортеж из двух значений: строка ```center_row``` и столбец ```center_col``` координат центра тяжести, определенного по элементам матрицы в указанной области, а также значение ```max_value``` самого большого элемента в указанной области
        """
        # Get the indices of the smaller region around the point
        row, col = point
        half_size = size // 2
        row_indices = range(max(0, row - half_size), min(matrix.shape[0], row + half_size + 1))
        col_indices = range(max(0, col - half_size), min(matrix.shape[1], col + half_size + 1))

        # Get the smaller region from the original matrix
        smaller_matrix = matrix[np.ix_(row_indices, col_indices)]
        max_value = np.max(smaller_matrix)

        # Calculate threshold as a fraction of the maximum value in the matrix
        threshold = np.max(smaller_matrix) * 0.1  # for example, we can use 10% of the maximum value as threshold

        # Find indices of elements above the threshold
        high_value_indices = np.where(smaller_matrix &gt; threshold)

        # If no elements exceed the threshold, return the center of the region
        if len(high_value_indices[0]) == 0:
            center_row = row_indices[len(row_indices) // 2]
            center_col = col_indices[len(col_indices) // 2]
        else:
            # Calculate center of mass using indices of elements above threshold
            center_row = np.mean(row_indices[high_value_indices[0]])
            center_col = np.mean(col_indices[high_value_indices[1]])

        return (center_row, center_col, max_value)

    @staticmethod
    def calculate_weighted_centroid(matrix: np.ndarray, point: tuple, target_level: float, xy_limits : tuple = None) -&gt; tuple:
        """Функция выполняет вычисление средневзвешенного значения координат внутри контура вокруг заданной точки. Внимание! Контур всегда должен быть полностью отображен в области поиска!

        Args:
            matrix (np.ndarray): матрица (двумерный массив) - изображение
            point (tuple): указанная точка - координаты
            level (float): уровень контура
            xy_limits (turple): область поиска контура (по умолчанию - все изображение)

        Returns:
            tuple: кортеж из двух значений: координаты (```weighted_x```, ```weighted_y```) - средневзвешенные координаты внутри контура.

        Raises:
            ValueError: если точка не находится внутри контура.
        """
        if xy_limits != None:
            crop_matrix = matrix[xy_limits[1][0]:xy_limits[1][1], xy_limits[0][0]:xy_limits[0][1]]
        else:
            crop_matrix = matrix
        contours = plt.contour(crop_matrix, levels=[crop_matrix.max() * target_level], extent=[xy_limits[0][0], xy_limits[0][1], xy_limits[1][0], xy_limits[1][1]])

        # Найти контур нужного уровня, содержащий точку
        point_in_contour = False
        for collection, level in zip(contours.collections, contours.levels):
            if level == crop_matrix.max() * target_level:
                for path in collection.get_paths():
                    if path.contains_point(point):
                        contour_path = path
                        point_in_contour = True
                        break
                if point_in_contour:
                    break

        if not point_in_contour:
            raise ValueError(f"Точка не находится внутри контура уровня {target_level}")

        # Создание сетки координат
        y, x = np.mgrid[:matrix.shape[0], :matrix.shape[1]]
        points = np.vstack((x.flatten(), y.flatten())).T

        # Создание маски для точек внутри контура
        mask = contour_path.contains_points(points).reshape(matrix.shape)

        # Извлечение координат и значений данных внутри контура
        x_coords = x[mask]
        y_coords = y[mask]
        values = matrix[mask]

        weighted_x = np.average(x_coords, weights=values)
        weighted_y = np.average(y_coords, weights=values)

        return (int(round(weighted_y)), int(round(weighted_x)), values.max())

    @staticmethod
    def replace_minus_to_zero(data: Union[str, np.ndarray]) -&gt; Tuple[np.ndarray, Header]:
        """Функция принимает на вход массив и возвращает его, заменяя отрицательные значения нулями. В случае, если массив является ```.fits``` файлом (т.е. путем к нему), функция также возвращает ```header```, чтобы его можно было сохранить в новом файле, в случае необходимости

        Args:
            data (Union[str, np.ndarray]): массив или путь к ```.fits``` файлу, где нужно заменить отрицательные значения нулями

        Returns:
            np.ndarray: очищенный от отрицательных значений массив
            Header: исходный заголовок ```.fits``` файла для возможности его пересохранения
        """
        if type(data) == str:
            hdul = fits.open(data)
            array_data = hdul[0].data
            header_data = hdul[0].header
            array_data[array_data &lt; 0] = 0
            return array_data, header_data

        elif type(data) == np.ndarray or type(data) == list:
            array_data = data
            array_data[array_data &lt; 0] = 0
            return np.array(array_data)

        else:
            Monitoring.logprint("Ошибка! Тип данных не соответствует")</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.ArrayOperations.calculate_weighted_centroid"><code class="name flex">
<span>def <span class="ident">calculate_weighted_centroid</span></span>(<span>matrix: numpy.ndarray, point: tuple, target_level: float, xy_limits: tuple = None) ‑&gt; tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Функция выполняет вычисление средневзвешенного значения координат внутри контура вокруг заданной точки. Внимание! Контур всегда должен быть полностью отображен в области поиска!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>матрица (двумерный массив) - изображение</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>указанная точка - координаты</dd>
<dt><strong><code>level</code></strong> : <code>float</code></dt>
<dd>уровень контура</dd>
<dt><strong><code>xy_limits</code></strong> : <code>turple</code></dt>
<dd>область поиска контура (по умолчанию - все изображение)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>кортеж из двух значений: координаты (<code>weighted_x</code>, <code>weighted_y</code>) - средневзвешенные координаты внутри контура.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>если точка не находится внутри контура.</dd>
</dl></div>
</dd>
<dt id="analise_utils.ArrayOperations.find_center_of_mass"><code class="name flex">
<span>def <span class="ident">find_center_of_mass</span></span>(<span>matrix: numpy.ndarray, point: tuple, size: int) ‑&gt; tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Функция выполняет поиск центра тяжести области методом взвешенного среднего. Функция вычисляет матрицу меньшего размера вокруг указанной точки и находит максимальное значение в этой области. Затем она устанавливает пороговое значение как фракцию максимального значения и находит индексы элементов матрицы, которые превышают этот порог. Если ни один элемент не превышает порог, центр тяжести вычисляется как центр области. В противном случае, используются индексы элементов, превышающих порог, для вычисления центра тяжести методом среднего.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>матрица (двумерный массив)</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>указанная точка - координаты</dd>
<dt><strong><code>size</code></strong> : <code>int</code></dt>
<dd>размер области поиска</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>кортеж из двух значений: строка <code>center_row</code> и столбец <code>center_col</code> координат центра тяжести, определенного по элементам матрицы в указанной области, а также значение <code>max_value</code> самого большого элемента в указанной области</dd>
</dl></div>
</dd>
<dt id="analise_utils.ArrayOperations.find_max_around_point"><code class="name flex">
<span>def <span class="ident">find_max_around_point</span></span>(<span>matrix: numpy.ndarray, point: tuple, size: int) ‑&gt; tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Функция выполняет поиск максимального значения в матрице определенного размера вокруг заданной точки.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>матрица (двумерный массив) - изображение</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>указанная точка - координаты</dd>
<dt><strong><code>size</code></strong> : <code>int</code></dt>
<dd>размер области поиска</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>кортеж из трех значений: строкa <code>max_row</code> и столбец <code>max_col</code> максимального значения, а также значение <code>max_value</code> самого большого элемента в указанной области.</dd>
</dl></div>
</dd>
<dt id="analise_utils.ArrayOperations.replace_minus_to_zero"><code class="name flex">
<span>def <span class="ident">replace_minus_to_zero</span></span>(<span>data: Union[str, numpy.ndarray]) ‑&gt; Tuple[numpy.ndarray, astropy.io.fits.header.Header]</span>
</code></dt>
<dd>
<div class="desc"><p>Функция принимает на вход массив и возвращает его, заменяя отрицательные значения нулями. В случае, если массив является <code>.fits</code> файлом (т.е. путем к нему), функция также возвращает <code>header</code>, чтобы его можно было сохранить в новом файле, в случае необходимости</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> : <code>Union[str, np.ndarray]</code></dt>
<dd>массив или путь к <code>.fits</code> файлу, где нужно заменить отрицательные значения нулями</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>очищенный от отрицательных значений массив</dd>
<dt><code>Header</code></dt>
<dd>исходный заголовок <code>.fits</code> файла для возможности его пересохранения</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.ConvertingArrays"><code class="flex name class">
<span>class <span class="ident">ConvertingArrays</span></span>
</code></dt>
<dd>
<div class="desc"><p>Преобразования массивов - сглаживание, аппроксимация, вычет подложки, пересчет в другую систему единиц, преобразвание в принт-строку, …</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvertingArrays:
    """
    Преобразования массивов - сглаживание, аппроксимация, вычет подложки, пересчет в другую систему единиц, преобразвание в принт-строку, ...
    """
    @staticmethod
    def arr2str4print(arr: Union[np.ndarray, List]) -&gt; str:
        """Преобразование массива чисел в принт-строку

        Args:
            arr (ndarray): массив чисел

        Returns:
            str: строка в удобном для вывода / логирования виде
        """
        return ", ".join(arr.astype(str))

    # def arr2str4print(arr):
    # return np.array2string(arr, separator=', ', formatter={'float_kind': lambda x: "%.2f" % x})

    @staticmethod
    def running_mean(data: np.ndarray, window_size: int) -&gt; np.ndarray:
        """Сглаживание массива скользящим усредняющим окном в указанное число элементов

        Args:
            array (np.ndarray): исходный массив

        Returns:
            np.ndarray: сглаженный массив
        """
        window = np.ones(window_size) / window_size
        smoothed_data = np.convolve(data, window, mode='same')
        return smoothed_data

    @staticmethod
    def variable_running_mean(array: np.ndarray) -&gt; np.ndarray:
        """Сглаживание массива скользящим усредняющим окном от 1 до 3 элементов ("окно" для вычисления среднего значения фактически изменяется в зависимости от позиции текущего элемента данных, для крайних значений данных используется среднее значение только из соседних элементов)

        Args:
            array (np.ndarray): исходный массив

        Returns:
            np.ndarray: сглаженный массив
        """
        smoothed_data = []
        for i in range(len(array)):
            if i == 0:
                smoothed_data.append((array[i] + array[i + 1]) / 2)
            elif i == len(array) - 1:
                smoothed_data.append((array[i - 1] + array[i]) / 2)
            else:
                smoothed_data.append((array[i - 1] + array[i] + array[i + 1 ]) / 3)

        return np.array(smoothed_data)

    @staticmethod
    def gs_approximation(array_sfu : np.ndarray, array_freqs : np.ndarray) -&gt; tuple[np.ndarray, np.ndarray]:
        """Аппроксимация массива уравнением, описывающим спектр гиросинхротронного излучения (Peak Frequency Dynamics in Solar Microwave Bursts, 2008). На выходе первый[0] элемент - аппроксимированный массив, второй[1] - список восстановленных параметров уравнения: [a1, a2, a3, a4]

        Args:
            array_sfu (np.ndarray): исходный массив интенсивностей
            array_freqs (np.ndarray): исходный массив частот

        Returns:
            np.ndarray: аппроксимированный массив
            np.ndarray: восстановленные параметры уравнения
        """

        def spectrum_function(array_freqs, a1, a2, a3, a4):
            return a1 * array_freqs**a2 * (1 - np.exp(-a3 * array_freqs**-a4))
        popt, pcov = curve_fit(spectrum_function, array_freqs, array_sfu)
        a1, a2, a3, a4 = popt
        print(f'Coeff: a1, a2, a3, a4 = {a1, a2, a3, a4}')
        approximation_arr = spectrum_function(array_freqs, *popt)
        return ((approximation_arr, np.array([a1, a2, a3, a4])))

    @staticmethod
    def background_subtraction(arr_left_flux: np.ndarray, arr_right_flux: np.ndarray, arr_freqs: np.ndarray):
        """Вычет подложки из области вспышки по интерполированной функции Zirin at el. Функция возвращает исходные массивы преобразованными

        Args:
            arr_left_flux (ndarray): массив данных левополяризованного излучения
            arr_right_flux (ndarray): массив данных правополяризованного излучения
            arr_freqs (ndarray): массив частот наблюдений

        Returns:
            ndarray: 2 преобразованных массива
        """
        zirin = ZirinTb()
        for index, freq in enumerate(arr_freqs):
            arr_left_flux[index]  = (arr_left_flux[index]  - zirin.getTbAtFrequency(freq/1000))
            arr_right_flux[index] = (arr_right_flux[index] - zirin.getTbAtFrequency(freq/1000))
        logging.info(f'Flux in sfu for LCP minus solar disk flux: [{ConvertingArrays.arr2str4print(arr_left_flux)}]')
        logging.info(f'Flux in sfu for RCP minus solar disk flux: [{ConvertingArrays.arr2str4print(arr_right_flux)}]')
        return arr_left_flux, arr_right_flux

    @staticmethod
    def Tb2sfu(arr_one_polarization: Union[np.ndarray, List], arr_freqs: Union[np.ndarray, List]) -&gt; np.ndarray:
        """Функция пересчета яркостной температуры в плотность солнечного потока ```sfu```

        Args:
            arr_one_polarization (Union[np.ndarray, List]): массив одной из поляризаций (левая/правая)
            arr_freqs (Union[np.ndarray, List]): массив частот наблюдений

        Returns:
            np.ndarray: преобразованный массив
        """
        return (((2 * 1.38*1e-16 * (np.array(arr_freqs) * 1e6) ** 2) / (3e10)**2) * np.array(arr_one_polarization) * ((2.4/3600*0.01745)**2) * 1e19)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.ConvertingArrays.Tb2sfu"><code class="name flex">
<span>def <span class="ident">Tb2sfu</span></span>(<span>arr_one_polarization: Union[numpy.ndarray, List], arr_freqs: Union[numpy.ndarray, List]) ‑&gt; numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Функция пересчета яркостной температуры в плотность солнечного потока <code>sfu</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr_one_polarization</code></strong> : <code>Union[np.ndarray, List]</code></dt>
<dd>массив одной из поляризаций (левая/правая)</dd>
<dt><strong><code>arr_freqs</code></strong> : <code>Union[np.ndarray, List]</code></dt>
<dd>массив частот наблюдений</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>преобразованный массив</dd>
</dl></div>
</dd>
<dt id="analise_utils.ConvertingArrays.arr2str4print"><code class="name flex">
<span>def <span class="ident">arr2str4print</span></span>(<span>arr: Union[numpy.ndarray, List]) ‑&gt; str</span>
</code></dt>
<dd>
<div class="desc"><p>Преобразование массива чисел в принт-строку</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> : <code>ndarray</code></dt>
<dd>массив чисел</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>строка в удобном для вывода / логирования виде</dd>
</dl></div>
</dd>
<dt id="analise_utils.ConvertingArrays.background_subtraction"><code class="name flex">
<span>def <span class="ident">background_subtraction</span></span>(<span>arr_left_flux: numpy.ndarray, arr_right_flux: numpy.ndarray, arr_freqs: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Вычет подложки из области вспышки по интерполированной функции Zirin at el. Функция возвращает исходные массивы преобразованными</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr_left_flux</code></strong> : <code>ndarray</code></dt>
<dd>массив данных левополяризованного излучения</dd>
<dt><strong><code>arr_right_flux</code></strong> : <code>ndarray</code></dt>
<dd>массив данных правополяризованного излучения</dd>
<dt><strong><code>arr_freqs</code></strong> : <code>ndarray</code></dt>
<dd>массив частот наблюдений</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>2 преобразованных массива</dd>
</dl></div>
</dd>
<dt id="analise_utils.ConvertingArrays.gs_approximation"><code class="name flex">
<span>def <span class="ident">gs_approximation</span></span>(<span>array_sfu: numpy.ndarray, array_freqs: numpy.ndarray) ‑&gt; tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Аппроксимация массива уравнением, описывающим спектр гиросинхротронного излучения (Peak Frequency Dynamics in Solar Microwave Bursts, 2008). На выходе первый[0] элемент - аппроксимированный массив, второй[1] - список восстановленных параметров уравнения: [a1, a2, a3, a4]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array_sfu</code></strong> : <code>np.ndarray</code></dt>
<dd>исходный массив интенсивностей</dd>
<dt><strong><code>array_freqs</code></strong> : <code>np.ndarray</code></dt>
<dd>исходный массив частот</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>аппроксимированный массив</dd>
<dt><code>np.ndarray</code></dt>
<dd>восстановленные параметры уравнения</dd>
</dl></div>
</dd>
<dt id="analise_utils.ConvertingArrays.running_mean"><code class="name flex">
<span>def <span class="ident">running_mean</span></span>(<span>data: numpy.ndarray, window_size: int) ‑&gt; numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Сглаживание массива скользящим усредняющим окном в указанное число элементов</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> : <code>np.ndarray</code></dt>
<dd>исходный массив</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>сглаженный массив</dd>
</dl></div>
</dd>
<dt id="analise_utils.ConvertingArrays.variable_running_mean"><code class="name flex">
<span>def <span class="ident">variable_running_mean</span></span>(<span>array: numpy.ndarray) ‑&gt; numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Сглаживание массива скользящим усредняющим окном от 1 до 3 элементов ("окно" для вычисления среднего значения фактически изменяется в зависимости от позиции текущего элемента данных, для крайних значений данных используется среднее значение только из соседних элементов)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>array</code></strong> : <code>np.ndarray</code></dt>
<dd>исходный массив</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>сглаженный массив</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.Extract"><code class="flex name class">
<span>class <span class="ident">Extract</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Extract:

    def __init__(self) -&gt; None:
        self.freqs_pattern = re.compile(r'(?&lt;=[_.])\d{4,5}(?=[_.])')   # паттерн извлечения частоты
        self.datetime_pattern = re.compile(r'\d{8}T\d{6}')             # паттерн для извлечения даты и времени
        self.polarization_pattern = re.compile(r'(RCP|LCP|R|L)')       # паттерн извлечения поляризации

    def extract_number(self, filename: str, freqs_array_name: set = None) -&gt; int:
        """Функция для извлечения цифр - номеров частот из названия файла. Если передать в качестве второго аргумента ```set()```, то он будет наполняться выделенными номерами частот

        Args:
            filename (str): название ```.fits``` файла с данными
            freqs_array_name (set, optional): для наполнения. По умолчанию None.

        Returns:
            int: выделенное число
        """
        match = self.freqs_pattern.search(filename)
        if freqs_array_name is not None:
            freqs_array_name.add(int(match.group()))
        return int(match.group())

    def extract_datetime(self, filename: str) -&gt; str:
        """Функция для извлечения даты и времени из названия файла.

        Args:
            filename (str): название ```.fits``` файла с данными или путь директории, вообщем - любая строка, содержащая дату и время в таком формате

        Returns:
            str: строка, содержащая извлеченную дату и время в формате "ГГГГММДДТЧЧММСС"
        """
        match = self.datetime_pattern.search(filename)
        return match.group()

    def extract_polarization(self, filename: str) -&gt; str:
        """Функция для извлечения поляризации из названия файла

        Args:
            filename (str): название ```.fits``` файла с данными

        Returns:
            str: выделенная поляризация (RCP, LCP, R, L)
        """
        match = self.polarization_pattern.search(filename)
        if match:
            return match.group()
        else:
            raise ValueError(f"Поляризация не найдена в названии файла: {filename}")</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="analise_utils.Extract.extract_datetime"><code class="name flex">
<span>def <span class="ident">extract_datetime</span></span>(<span>self, filename: str) ‑&gt; str</span>
</code></dt>
<dd>
<div class="desc"><p>Функция для извлечения даты и времени из названия файла.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> : <code>str</code></dt>
<dd>название <code>.fits</code> файла с данными или путь директории, вообщем - любая строка, содержащая дату и время в таком формате</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>строка, содержащая извлеченную дату и время в формате "ГГГГММДДТЧЧММСС"</dd>
</dl></div>
</dd>
<dt id="analise_utils.Extract.extract_number"><code class="name flex">
<span>def <span class="ident">extract_number</span></span>(<span>self, filename: str, freqs_array_name: set = None) ‑&gt; int</span>
</code></dt>
<dd>
<div class="desc"><p>Функция для извлечения цифр - номеров частот из названия файла. Если передать в качестве второго аргумента <code>set()</code>, то он будет наполняться выделенными номерами частот</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> : <code>str</code></dt>
<dd>название <code>.fits</code> файла с данными</dd>
<dt><strong><code>freqs_array_name</code></strong> : <code>set</code>, optional</dt>
<dd>для наполнения. По умолчанию None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>выделенное число</dd>
</dl></div>
</dd>
<dt id="analise_utils.Extract.extract_polarization"><code class="name flex">
<span>def <span class="ident">extract_polarization</span></span>(<span>self, filename: str) ‑&gt; str</span>
</code></dt>
<dd>
<div class="desc"><p>Функция для извлечения поляризации из названия файла</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> : <code>str</code></dt>
<dd>название <code>.fits</code> файла с данными</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>выделенная поляризация (RCP, LCP, R, L)</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.FindIntensity"><code class="flex name class">
<span>class <span class="ident">FindIntensity</span></span>
</code></dt>
<dd>
<div class="desc"><p>Получение суммарной интенсивности из пикселя, пикселя и окружающей области (4, 9, size), от всего Солнца</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindIntensity:
    """
    Получение суммарной интенсивности из пикселя, пикселя и окружающей области (4, 9, size), от всего Солнца
    """

    @staticmethod
    def find_intensity_in_point(matrix: np.ndarray, point: tuple) -&gt; float:
        """Интенсивность из одного пикселя

        Args:
            matrix (np.ndarray): массив данных изображения
            point (tuple): координаты точки

        Returns:
            float: интенсивность из пикселя
        """
        x, y = point
        return matrix[y][x]

    @staticmethod
    def find_intensity_in_four_point(matrix: np.ndarray, point: tuple) -&gt; float:
        """Интенсивность из четырех пикселей. Берется указанная точка + три точки с правой стороны от него

        Args:
            matrix (np.ndarray): массив данных изображения
            point (tuple): координаты точки

        Returns:
            float: интенсивность из пикселя
        """
        x, y = point
        intensity_sum = matrix[y][x] + matrix[y][x+1] + matrix[y+1][x] + matrix[y+1][x+1]
        intensity_avg = intensity_sum
        return intensity_avg

    @staticmethod
    def find_intensity_in_nine_point(matrix: np.ndarray, point: tuple) -&gt; float:
        """Интенсивность из девяти пикселей. Берется указанная точка + восемь точек вокруг нее

        Args:
            matrix (np.ndarray): массив данных изображения
            point (tuple): координаты точки

        Returns:
            float: интенсивность из пикселя
        """
        x, y = point
        intensity_sum = matrix[y+1][x-1] + matrix[y+1][x] + matrix[y+1][x+1] + matrix[y][x-1] + matrix[y][x] + matrix[y][x+1] + matrix[y-1][x-1] + matrix[y-1][x] + matrix[y-1][x+1]
        intensity_avg = intensity_sum
        return intensity_avg

    @staticmethod
    def find_intensity_in_alotof_point(matrix: np.ndarray, point: tuple) -&gt; float:
        x, y = point
        data_array = matrix[y-20:y+20, x-12:x+12]
        fig = plt.figure()
        plt.imshow(data_array)
        plt.plot()
        mask = data_array &gt; 0
        data_array = data_array[mask]
        intensity_avg = np.sum(data_array)
        return intensity_avg

    @staticmethod
    def find_intensity_in_sun_disk(matrix: np.ndarray, point: tuple) -&gt; float:
        x1, y1 = np.indices(matrix.shape)
        center_x, center_y = 512, 512
        radius = 405

        # вычисляем расстояние от каждой точки до центра окружности
        distance_from_center = np.sqrt((x1 - center_x)**2 + (y1 - center_y)**2)
        mask = distance_from_center &lt;= radius
        data_inside_circle = matrix[mask]
        mask = data_inside_circle &gt; 0
        data_inside_circle = data_inside_circle[mask]
        print(len(data_inside_circle))
        intensity_avg = np.sum(data_inside_circle)
        return intensity_avg</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.FindIntensity.find_intensity_in_alotof_point"><code class="name flex">
<span>def <span class="ident">find_intensity_in_alotof_point</span></span>(<span>matrix: numpy.ndarray, point: tuple) ‑&gt; float</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="analise_utils.FindIntensity.find_intensity_in_four_point"><code class="name flex">
<span>def <span class="ident">find_intensity_in_four_point</span></span>(<span>matrix: numpy.ndarray, point: tuple) ‑&gt; float</span>
</code></dt>
<dd>
<div class="desc"><p>Интенсивность из четырех пикселей. Берется указанная точка + три точки с правой стороны от него</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>массив данных изображения</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>координаты точки</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>интенсивность из пикселя</dd>
</dl></div>
</dd>
<dt id="analise_utils.FindIntensity.find_intensity_in_nine_point"><code class="name flex">
<span>def <span class="ident">find_intensity_in_nine_point</span></span>(<span>matrix: numpy.ndarray, point: tuple) ‑&gt; float</span>
</code></dt>
<dd>
<div class="desc"><p>Интенсивность из девяти пикселей. Берется указанная точка + восемь точек вокруг нее</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>массив данных изображения</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>координаты точки</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>интенсивность из пикселя</dd>
</dl></div>
</dd>
<dt id="analise_utils.FindIntensity.find_intensity_in_point"><code class="name flex">
<span>def <span class="ident">find_intensity_in_point</span></span>(<span>matrix: numpy.ndarray, point: tuple) ‑&gt; float</span>
</code></dt>
<dd>
<div class="desc"><p>Интенсивность из одного пикселя</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> : <code>np.ndarray</code></dt>
<dd>массив данных изображения</dd>
<dt><strong><code>point</code></strong> : <code>tuple</code></dt>
<dd>координаты точки</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>интенсивность из пикселя</dd>
</dl></div>
</dd>
<dt id="analise_utils.FindIntensity.find_intensity_in_sun_disk"><code class="name flex">
<span>def <span class="ident">find_intensity_in_sun_disk</span></span>(<span>matrix: numpy.ndarray, point: tuple) ‑&gt; float</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.Monitoring"><code class="flex name class">
<span>class <span class="ident">Monitoring</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Monitoring:

    @staticmethod
    def start_log(name_file : str):
        """Инициализация ```.log``` файла

        Args:
            name_file (str): название файла
        """
        logging.basicConfig(filename = f'{name_file}.log',  filemode='a', level = logging.INFO, format = '%(asctime)s - %(levelname)s - %(message)s', datefmt='%d-%b-%y %H:%M:%S')
        # encoding = "UTF-8"

    @staticmethod
    def logprint(info_msg : str):
        """Вывод отладочной информации и в консоль, и в ```.log``` файл

        Args:
            info_msg (str): строка с отладочной информацией
        """
        print(info_msg)
        logging.info(info_msg)

    @staticmethod
    def header_info(header: Header):
        """Выводит основную информацию из ```header``` в ```.fits``` файле

        Args:
            header (Header): заголовок ```.fits``` файла
        """
        Monitoring.logprint(f'Дата: {header['DATE-OBS']}\nВремя: {header['T-OBS']}\nИнструмент: {header['INSTRUME']}\nЧастота: {header['FREQUENC']}\nРазмер изображения: {header['NAXIS1']}')</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.Monitoring.header_info"><code class="name flex">
<span>def <span class="ident">header_info</span></span>(<span>header: astropy.io.fits.header.Header)</span>
</code></dt>
<dd>
<div class="desc"><p>Выводит основную информацию из <code>header</code> в <code>.fits</code> файле</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header</code></strong> : <code>Header</code></dt>
<dd>заголовок <code>.fits</code> файла</dd>
</dl></div>
</dd>
<dt id="analise_utils.Monitoring.logprint"><code class="name flex">
<span>def <span class="ident">logprint</span></span>(<span>info_msg: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Вывод отладочной информации и в консоль, и в <code>.log</code> файл</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>info_msg</code></strong> : <code>str</code></dt>
<dd>строка с отладочной информацией</dd>
</dl></div>
</dd>
<dt id="analise_utils.Monitoring.start_log"><code class="name flex">
<span>def <span class="ident">start_log</span></span>(<span>name_file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Инициализация <code>.log</code> файла</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name_file</code></strong> : <code>str</code></dt>
<dd>название файла</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.MplFunction"><code class="flex name class">
<span>class <span class="ident">MplFunction</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MplFunction:

    @staticmethod
    def set_mpl_rc():
        """Функция, применяющая выверенные стандарты отображения MPL для удобства: размеры шрифтов, линий и пр."""

        SMALL_SIZE = 18
        MEDIUM_SIZE = 20
        BIGGER_SIZE = 25

        plt.rc('font', size=MEDIUM_SIZE)                    # размер шрифта по умолчанию
        plt.rc('axes', titlesize=BIGGER_SIZE)               # размер шрифта заголовков
        plt.rc('axes', labelsize=MEDIUM_SIZE)               # размер шрифта подписей осей
        plt.rc('xtick', labelsize=SMALL_SIZE)               # размер шрифта меток по оси x
        plt.rc('ytick', labelsize=SMALL_SIZE)               # размер шрифта меток по оси y
        plt.rc('legend', fontsize=MEDIUM_SIZE)              # размер шрифта легенды
        plt.rc('figure', titlesize=BIGGER_SIZE)             # размер шрифта заголовка фигуры
        plt.rc('lines', linewidth=6)                        # толщина линий
        plt.rc('grid', linestyle='--', linewidth=1)       # стиль и толщина линий сетки
        plt.rc('axes', grid=True)                           # отображение сетки на осях

        # Отключение предупреждений о попытке установки неположительных границ оси на логарифмической шкале при очистке графика
        warnings.filterwarnings('ignore', message='UserWarning: Attempt to set non-positive xlim on a log-scaled axis will be ignored.')

    @staticmethod
    def remove_ticks_in_log(axes):
        """shit code - не работает на 2+ осях, не ведаю почему, но код пусть будет
        Args:
            axes (_type_): _description_
        """
        axes.xaxis.set_major_formatter(ScalarFormatter())
        axes.xaxis.set_minor_formatter(NullFormatter())
        axes.xaxis.set_minor_locator(ticker.NullLocator())</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.MplFunction.remove_ticks_in_log"><code class="name flex">
<span>def <span class="ident">remove_ticks_in_log</span></span>(<span>axes)</span>
</code></dt>
<dd>
<div class="desc"><p>shit code - не работает на 2+ осях, не ведаю почему, но код пусть будет</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>axes</code></strong> : <code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="analise_utils.MplFunction.set_mpl_rc"><code class="name flex">
<span>def <span class="ident">set_mpl_rc</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Функция, применяющая выверенные стандарты отображения MPL для удобства: размеры шрифтов, линий и пр.</p></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.OsOperations"><code class="flex name class">
<span>class <span class="ident">OsOperations</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OsOperations:

    @staticmethod
    def create_place(path: str, postfix: str = ''):
        """Создает папку с указанным путем, если она уже существует - удаляет ее и создает заново.
        Вторым аргументом можно передать постфикс для пути

        Args:
            path (str): путь к месту расположения
            postfix (str, optional): постфикс для пути, отделяется от пути нижним подчеркиванием ```_```. По умолчанию пустая строка: ''
        """
        new_path = f'{path}_{postfix}' if postfix else path
        try:
            os.mkdir(new_path)
        except FileNotFoundError:
            os.makedirs(os.path.dirname(new_path), exist_ok=True)
            os.mkdir(new_path)
        except FileExistsError:
            shutil.rmtree(new_path)
            os.mkdir(new_path)

# Пример использования
# Utility.create_place('some/intermediate/path', 'postfix')


    @staticmethod
    def abс_sorted_files_in_folder(path_to_folder) -&gt; List[str]:
        """Создает список файлов в указанной папке, отсортированных по АЛФАВИТУ / ВРЕМЕНИ

        Args:
            path_to_folder (str): путь к месту расположения файлов
        Returns:
            files (list): список файлов в указанной папке
        """
        files = sorted(os.listdir(path_to_folder))
        return files

    @staticmethod
    def freq_sorted_files_in_folder(path_to_folder) -&gt; Tuple[List[str], List[int]]:
        """Создает список файлов в указанной папке, отсортированных по ЧАСТОТАМ

        Args:
            path_to_folder (str): путь к месту расположения файлов
        Returns:
            files (list): список файлов в указанной папке
            freqs (list): список частот от меньшей к большей
        """
        extract = Extract()
        freqs = set()
        files = sorted(os.listdir(path_to_folder), key=lambda x: extract.extract_number(x, freqs))
        freqs = sorted(list(freqs))
        return files, freqs

    @staticmethod
    def freq_sorted_1st_two_files_in_folders(path_to_folder : str, type_path : str = 'relative') -&gt; Tuple[List[str], List[int]]:
        """Создает список из двух первых (по алфавиту/времени) файлов в каждой из подпапок в указанной папке, отсортированный по ЧАСТОТАМ

        Args:
            path_to_folder (str): путь к месту расположения папок с файлами
            type_path (str): желаемый путь на выходе: только имена файлов ```relative``` или полный ```full```
        Returns:
            files (list): список из двух первых файлов в каждой из подпапок
            freqs (list): список частот от меньшей к большей
        """
        extract = Extract()
        freqs = set()
        list_of_1st_two_files = []
        list_folders_in_folder = sorted(os.listdir(path_to_folder))
        for freq_folder in list_folders_in_folder:
            list_of_files = sorted(os.listdir(f'{path_to_folder}/{freq_folder}'))
            try:
                list_of_1st_two_files.append(f'{path_to_folder}/{freq_folder}/{list_of_files[0]}') if type_path == 'full' else list_of_1st_two_files.append(f'{list_of_files[0]}')
                list_of_1st_two_files.append(f'{path_to_folder}/{freq_folder}/{list_of_files[1]}') if type_path == 'full' else list_of_1st_two_files.append(f'{list_of_files[1]}')
            except IndexError as err:
                Monitoring.logprint(f"Похоже, есть пустая папка. Проверьте папку {freq_folder}. Ошибка: {err}")
        files = sorted(list_of_1st_two_files, key=lambda x: extract.extract_number(x, freqs))
        freqs = sorted(list(freqs))
        return files, freqs</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.OsOperations.abс_sorted_files_in_folder"><code class="name flex">
<span>def <span class="ident">abс_sorted_files_in_folder</span></span>(<span>path_to_folder) ‑&gt; List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Создает список файлов в указанной папке, отсортированных по АЛФАВИТУ / ВРЕМЕНИ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_to_folder</code></strong> : <code>str</code></dt>
<dd>путь к месту расположения файлов</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>files (list): список файлов в указанной папке</p></div>
</dd>
<dt id="analise_utils.OsOperations.create_place"><code class="name flex">
<span>def <span class="ident">create_place</span></span>(<span>path: str, postfix: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Создает папку с указанным путем, если она уже существует - удаляет ее и создает заново.
Вторым аргументом можно передать постфикс для пути</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> : <code>str</code></dt>
<dd>путь к месту расположения</dd>
<dt><strong><code>postfix</code></strong> : <code>str</code>, optional</dt>
<dd>постфикс для пути, отделяется от пути нижним подчеркиванием <code>_</code>. По умолчанию пустая строка: ''</dd>
</dl></div>
</dd>
<dt id="analise_utils.OsOperations.freq_sorted_1st_two_files_in_folders"><code class="name flex">
<span>def <span class="ident">freq_sorted_1st_two_files_in_folders</span></span>(<span>path_to_folder: str, type_path: str = 'relative') ‑&gt; Tuple[List[str], List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Создает список из двух первых (по алфавиту/времени) файлов в каждой из подпапок в указанной папке, отсортированный по ЧАСТОТАМ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_to_folder</code></strong> : <code>str</code></dt>
<dd>путь к месту расположения папок с файлами</dd>
<dt><strong><code>type_path</code></strong> : <code>str</code></dt>
<dd>желаемый путь на выходе: только имена файлов <code>relative</code> или полный <code>full</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>files (list): список из двух первых файлов в каждой из подпапок
freqs (list): список частот от меньшей к большей</p></div>
</dd>
<dt id="analise_utils.OsOperations.freq_sorted_files_in_folder"><code class="name flex">
<span>def <span class="ident">freq_sorted_files_in_folder</span></span>(<span>path_to_folder) ‑&gt; Tuple[List[str], List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Создает список файлов в указанной папке, отсортированных по ЧАСТОТАМ</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path_to_folder</code></strong> : <code>str</code></dt>
<dd>путь к месту расположения файлов</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>files (list): список файлов в указанной папке
freqs (list): список частот от меньшей к большей</p></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.Properties"><code class="flex name class">
<span>class <span class="ident">Properties</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Properties():

    @staticmethod
    def init_customization():

        # отображение всех значений матрицы в консоль
        np.set_printoptions(threshold=np.inf)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="analise_utils.Properties.init_customization"><code class="name flex">
<span>def <span class="ident">init_customization</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="analise_utils.ZirinTb"><code class="flex name class">
<span>class <span class="ident">ZirinTb</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZirinTb:
# Zirin H. et al.
# The Microwave Brightness Temperature Spectrum of the Quiet Sun
# The Astrophysical Journal. 1991

    def fitFunc(self, f, A, B, C):
        return A + B*f + C*f**-1.8

    def __init__(self):

        self.frequency = np.array([1.4, 1.6, 1.8, 2.0, 2.4, 2.8, 3.2, 3.6, 4.2, 5.0, 5.8, 7.0, 8.2, 9.4, 10.6, 11.8, 13.2, 14.8, 16.4, 18.0]) # frequency [GHz]
        self.Tb = np.array([70.5, 63.8, 52.2, 42.9, 32.8, 27.1, 24.2, 21.7, 19.4, 17.6, 15.9, 14.1, 12.9, 12.2, 11.3, 11.0, 10.8, 10.8, 10.7, 10.3]) # brightness temperature [1e3K]
        self.guess = [1, 1, 1]
        self.fitTbParams, _ = opt.curve_fit(self.fitFunc, self.frequency, self.Tb, p0=self.guess)
        self.solarDiskRadius = np.deg2rad(900/3600)

    def getTbAtFrequency(self, f):
        return self.fitFunc(f, self.fitTbParams[0],self.fitTbParams[1],self.fitTbParams[2])

    def getSfuAtFrequency(self, f):
        return 2*constants.k*self.getTbAtFrequency(f)*1e3/(constants.c/(f*1e9))**2 * np.pi*self.solarDiskRadius**2 / 1e-22</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="analise_utils.ZirinTb.fitFunc"><code class="name flex">
<span>def <span class="ident">fitFunc</span></span>(<span>self, f, A, B, C)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="analise_utils.ZirinTb.getSfuAtFrequency"><code class="name flex">
<span>def <span class="ident">getSfuAtFrequency</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="analise_utils.ZirinTb.getTbAtFrequency"><code class="name flex">
<span>def <span class="ident">getTbAtFrequency</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a href="#analise_utils.ArrayOperations" title="analise_utils.ArrayOperations">ArrayOperations</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.ArrayOperations.calculate_weighted_centroid" title="analise_utils.ArrayOperations.calculate_weighted_centroid">calculate_weighted_centroid</a></code></li>
<li><code><a href="#analise_utils.ArrayOperations.find_center_of_mass" title="analise_utils.ArrayOperations.find_center_of_mass">find_center_of_mass</a></code></li>
<li><code><a href="#analise_utils.ArrayOperations.find_max_around_point" title="analise_utils.ArrayOperations.find_max_around_point">find_max_around_point</a></code></li>
<li><code><a href="#analise_utils.ArrayOperations.replace_minus_to_zero" title="analise_utils.ArrayOperations.replace_minus_to_zero">replace_minus_to_zero</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.ConvertingArrays" title="analise_utils.ConvertingArrays">ConvertingArrays</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.ConvertingArrays.Tb2sfu" title="analise_utils.ConvertingArrays.Tb2sfu">Tb2sfu</a></code></li>
<li><code><a href="#analise_utils.ConvertingArrays.arr2str4print" title="analise_utils.ConvertingArrays.arr2str4print">arr2str4print</a></code></li>
<li><code><a href="#analise_utils.ConvertingArrays.background_subtraction" title="analise_utils.ConvertingArrays.background_subtraction">background_subtraction</a></code></li>
<li><code><a href="#analise_utils.ConvertingArrays.gs_approximation" title="analise_utils.ConvertingArrays.gs_approximation">gs_approximation</a></code></li>
<li><code><a href="#analise_utils.ConvertingArrays.running_mean" title="analise_utils.ConvertingArrays.running_mean">running_mean</a></code></li>
<li><code><a href="#analise_utils.ConvertingArrays.variable_running_mean" title="analise_utils.ConvertingArrays.variable_running_mean">variable_running_mean</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.Extract" title="analise_utils.Extract">Extract</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.Extract.extract_datetime" title="analise_utils.Extract.extract_datetime">extract_datetime</a></code></li>
<li><code><a href="#analise_utils.Extract.extract_number" title="analise_utils.Extract.extract_number">extract_number</a></code></li>
<li><code><a href="#analise_utils.Extract.extract_polarization" title="analise_utils.Extract.extract_polarization">extract_polarization</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.FindIntensity" title="analise_utils.FindIntensity">FindIntensity</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.FindIntensity.find_intensity_in_alotof_point" title="analise_utils.FindIntensity.find_intensity_in_alotof_point">find_intensity_in_alotof_point</a></code></li>
<li><code><a href="#analise_utils.FindIntensity.find_intensity_in_four_point" title="analise_utils.FindIntensity.find_intensity_in_four_point">find_intensity_in_four_point</a></code></li>
<li><code><a href="#analise_utils.FindIntensity.find_intensity_in_nine_point" title="analise_utils.FindIntensity.find_intensity_in_nine_point">find_intensity_in_nine_point</a></code></li>
<li><code><a href="#analise_utils.FindIntensity.find_intensity_in_point" title="analise_utils.FindIntensity.find_intensity_in_point">find_intensity_in_point</a></code></li>
<li><code><a href="#analise_utils.FindIntensity.find_intensity_in_sun_disk" title="analise_utils.FindIntensity.find_intensity_in_sun_disk">find_intensity_in_sun_disk</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.Monitoring" title="analise_utils.Monitoring">Monitoring</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.Monitoring.header_info" title="analise_utils.Monitoring.header_info">header_info</a></code></li>
<li><code><a href="#analise_utils.Monitoring.logprint" title="analise_utils.Monitoring.logprint">logprint</a></code></li>
<li><code><a href="#analise_utils.Monitoring.start_log" title="analise_utils.Monitoring.start_log">start_log</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.MplFunction" title="analise_utils.MplFunction">MplFunction</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.MplFunction.remove_ticks_in_log" title="analise_utils.MplFunction.remove_ticks_in_log">remove_ticks_in_log</a></code></li>
<li><code><a href="#analise_utils.MplFunction.set_mpl_rc" title="analise_utils.MplFunction.set_mpl_rc">set_mpl_rc</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.OsOperations" title="analise_utils.OsOperations">OsOperations</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.OsOperations.abс_sorted_files_in_folder" title="analise_utils.OsOperations.abс_sorted_files_in_folder">abс_sorted_files_in_folder</a></code></li>
<li><code><a href="#analise_utils.OsOperations.create_place" title="analise_utils.OsOperations.create_place">create_place</a></code></li>
<li><code><a href="#analise_utils.OsOperations.freq_sorted_1st_two_files_in_folders" title="analise_utils.OsOperations.freq_sorted_1st_two_files_in_folders">freq_sorted_1st_two_files_in_folders</a></code></li>
<li><code><a href="#analise_utils.OsOperations.freq_sorted_files_in_folder" title="analise_utils.OsOperations.freq_sorted_files_in_folder">freq_sorted_files_in_folder</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.Properties" title="analise_utils.Properties">Properties</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.Properties.init_customization" title="analise_utils.Properties.init_customization">init_customization</a></code></li>
</ul>
</li>
<li>
<h4><code><a href="#analise_utils.ZirinTb" title="analise_utils.ZirinTb">ZirinTb</a></code></h4>
<ul class="">
<li><code><a href="#analise_utils.ZirinTb.fitFunc" title="analise_utils.ZirinTb.fitFunc">fitFunc</a></code></li>
<li><code><a href="#analise_utils.ZirinTb.getSfuAtFrequency" title="analise_utils.ZirinTb.getSfuAtFrequency">getSfuAtFrequency</a></code></li>
<li><code><a href="#analise_utils.ZirinTb.getTbAtFrequency" title="analise_utils.ZirinTb.getTbAtFrequency">getTbAtFrequency</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
