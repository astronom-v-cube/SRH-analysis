freqs = [2800.0000000000014, 2920.4285706792753, 3046.036798728497, 3177.0474622668344, 3313.6929211457664, 3456.2155290613427, 3604.868063391474, 3759.91417352062, 3921.6288484469887, 4090.2989045016598, 4266.223494044565, 4449.71463603961, 4641.09776944993, 4840.712330434795, 5048.912354371867, 5266.067103772557, 5492.561723204154, 5728.797922380285, 5975.194688631233, 6232.18903001775, 6500.23675040636, 6779.813257880763, 7071.414407923253, 7375.557382861475, 7692.781609140395, 8023.649714046318, 8368.748523579805, 8728.690103247305, 9104.112843617448, 9495.68259256733, 9904.093836226953, 10330.070930716329, 10774.369386859777, 11237.777210156235, 11721.116298381663, 12225.24389930298, 12751.05413108817, 13299.47956810997, 13871.492894954847, 14468.10863157169, 15090.384932619078, 15739.425464203123, 16416.38136133419, 17122.453269573944, 17858.89347449448, 18627.008122725456, 19428.159538529424, 20263.76864001298, 21135.317459260234, 22044.351770857145, 22992.48383346983, 23981.395249338053, 25012.83994675683, 26088.64729083449, 27210.725328045504, 28381.064170332265, 29601.739524757188, 30874.91637496675, 32202.852820995056, 33587.90408421919, 35032.52668456739, 36539.28279739099, 38110.84479772516, 39750.000000000015]

import numpy as np
import matplotlib.pyplot as plt

def adaptive_sampling(freqs, data, n_points=20):
    freqs = np.array(freqs)
    data = np.array(data)

    # 1. Вычисляем производную (градиент по частоте)
    df = np.gradient(data, freqs)
    importance = np.abs(df)

    # 2. Нормируем и строим кумулятивную метрику
    importance += 1e-12  # чтобы не было нулей
    cumulative = np.cumsum(importance)
    cumulative = cumulative / cumulative[-1]  # нормируем до [0, 1]

    # 3. Создаём равномерную сетку по значимости
    targets = np.linspace(0, 1, n_points)

    # 4. Для каждой целевой значимости находим ближайший индекс
    indices = [np.abs(cumulative - t).argmin() for t in targets]

    # Удалим дубликаты
    indices = sorted(set(indices))

    return freqs[indices].tolist(), data[indices].tolist()


from scipy.interpolate import interp1d

def adaptive_interpolated_sampling(freqs, data, n_points=30, round_to=100):
    freqs = np.array(freqs)
    data = np.array(data)

    # Интерполяция по логарифмической шкале частот для стабильности
    log_freqs = np.log10(freqs)
    interp_func = interp1d(log_freqs, data, kind='cubic', fill_value="extrapolate")

    # Высокая разрешающая способность для оценки производной
    dense_log_freqs = np.linspace(log_freqs.min(), log_freqs.max(), 5000)
    dense_data = interp_func(dense_log_freqs)

    # Оцениваем производную (градиент) и строим функцию значимости
    gradient = np.abs(np.gradient(dense_data, dense_log_freqs))
    importance = gradient + 1e-12  # защита от нуля

    cumulative = np.cumsum(importance)
    cumulative /= cumulative[-1]

    # Выбираем n_points равномерно по значимости
    targets = np.linspace(0, 1, n_points)
    indices = [np.abs(cumulative - t).argmin() for t in targets]

    selected_log_freqs = dense_log_freqs[indices]
    selected_freqs = 10**selected_log_freqs
    selected_freqs = np.round(selected_freqs / round_to) * round_to
    selected_freqs = np.unique(selected_freqs)  # убрать повторы после округления

    # Теперь интерполируем исходную аппроксимацию на новых частотах
    log_interp_final = interp1d(log_freqs, data, kind='cubic', fill_value="extrapolate")
    final_data = log_interp_final(np.log10(selected_freqs))

    return selected_freqs.tolist(), final_data.tolist()


import numpy as np
from scipy.interpolate import interp1d

def adaptive_resample(freqs, data, n_points=30, round_to=100):
    """
    Адаптивная ресемплировка спектра.

    Аргументы:
    - freqs: исходные частоты (МГц)
    - data: значения спектра
    - n_points: сколько точек выбрать в финале
    - round_to: округление частот (в МГц), например 100 → [2800, 2900, ...]

    Возвращает:
    - resampled_freqs: новые частоты
    - resampled_data: значения на этих частотах
    """
    freqs = np.array(freqs)
    data = np.array(data)

    # Интерполяция в log(freq), чтобы избежать искажений
    log_freqs = np.log10(freqs)
    interp_func = interp1d(log_freqs, data, kind='cubic', fill_value="extrapolate")

    # Строим плотную сетку для оценки производной
    dense_log_freqs = np.linspace(log_freqs.min(), log_freqs.max(), 5000)
    dense_data = interp_func(dense_log_freqs)

    # Оцениваем "важность" точки как модуль производной
    importance = np.abs(np.gradient(dense_data, dense_log_freqs))
    importance += 1e-12  # защита от деления на 0

    # Интеграл значимости — нормированная кумулятивная сумма
    cumulative = np.cumsum(importance)
    cumulative /= cumulative[-1]

    # Равномерно распределяем n_points по значимости
    target_cumulative = np.linspace(0, 1, n_points)
    indices = [np.abs(cumulative - t).argmin() for t in target_cumulative]
    selected_log_freqs = dense_log_freqs[indices]
    selected_freqs = 10**selected_log_freqs

    # Округление частот
    selected_freqs = np.round(selected_freqs / round_to) * round_to
    selected_freqs = np.clip(selected_freqs, freqs.min(), freqs.max())
    selected_freqs = np.unique(selected_freqs)

    # Интерполируем спектр на новых частотах
    interp_final = interp1d(freqs, data, kind='cubic', fill_value="extrapolate")
    resampled_data = interp_final(selected_freqs)

    return selected_freqs.tolist(), resampled_data.tolist()



"""
Вспышка 14 мая 2024 года
Берется три области: северное [1] и южное основание [3], а также вершина [2]
"""
# [3]
spectrum_20240514_position_3_time_020434_LCP = [0.07224668165106952, 0.08808034650863454, 0.10727686210012992, 0.1305181876285815, 0.15861498651501674, 0.19252809218481803, 0.23339272236872693, 0.2825455401791549, 0.3415545717706639, 0.4122518654386535, 0.496768607500179, 0.5975721877009235, 0.7175044226664382, 0.8598197922582589, 1.0282221145746955, 1.226897577903748, 1.4605414643451848, 1.7343752494656954, 2.0541500645008863, 2.426131794317814, 2.8570624034189462, 3.354091500022167, 3.9246717514961427, 4.5764116610336645, 5.316879532680873, 6.1533533315383115, 7.092512735471849, 8.140072112801995, 9.300356557644545, 10.575827527654912, 11.96657003106918, 13.46975955842088, 15.07913375976557, 16.78450077088891, 18.571322451990696, 20.42041581218557, 22.307818619525264, 24.204864657429614, 26.07850936874668, 27.891937025628124, 29.6054657545213, 31.177746953712592, 32.56723176783252, 33.73385097795657, 34.64082828977656, 35.25652347422069, 35.55618431815866, 35.523477917668096, 35.15167491097081, 34.44437612089156, 33.41569958883327, 32.08988527276715, 30.500321245143052, 28.68804424611541, 26.69981339006352, 24.585893216376228, 22.397706535520918, 20.185525683947528, 17.996362007086873, 15.872189027539406, 13.848598229124018, 11.953942548896219, 10.208977032657444, 8.626963997362742]

spectrum_20240514_position_3_time_020434_RCP = [0.06140472449590693, 0.07479660623917665, 0.09105451165117576, 0.11077454010776808, 0.1346713480177909, 0.1636000308359464, 0.19858151183176323, 0.24083182974712483, 0.2917957029435903, 0.3531847065822102, 0.42702032193023737, 0.5156819909169036, 0.621960119978243, 0.7491137079622533, 0.9009319040357777, 1.0817983120183647, 1.2967562255474268, 1.5515721831985174, 1.8527942571267693, 2.2078003235044386, 2.624830211301951, 3.1129941105635384, 3.682247992776383, 4.343325142107303, 5.1076113528666705, 5.98695010919204, 6.993363387373491, 8.138673938919167, 9.434016418131158, 10.889227955000244, 12.512114200910577, 14.30759490878449, 16.27674404784064, 18.415753366294147, 20.714864919729216, 23.157336605654546, 25.718523799592706, 28.365177694978016, 31.055074138424906, 33.73709229799758, 36.35185682809974, 38.833036971853204, 41.10935887305147, 43.107332594531954, 44.754624837680815, 45.983927163915894, 46.73708602714264, 46.96918645959853, 46.65222885769191, 45.7780207734577, 44.35993290731284, 42.43324512189199, 40.05393112561628, 37.295887771377195, 34.246787081757304, 31.002891346905166, 27.663298213344024, 24.32415200028998, 21.073356789044407, 17.98625530337608, 15.12260691105514, 12.52503018564485, 10.218898069687482, 8.213514485624296]

print(len(freqs))

print(len(spectrum_20240514_position_3_time_020434_RCP))
new_freqs, new_data = adaptive_resample(freqs, spectrum_20240514_position_3_time_020434_RCP, n_points=30, round_to=100)

plt.plot(new_freqs, new_data)
plt.loglog()
plt.show()


